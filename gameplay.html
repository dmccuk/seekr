<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Seekr.run, Gameplay</title>
  <link rel="icon" type="image/x-icon" href="assets/seekr-favicon.ico" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800;900&display=swap" rel="stylesheet">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <style>
    :root{
      --ink:#0e1220; --muted:#55627a; --bg:#f6f8fc; --card:#ffffff;
      --brand:#1e4cff; --accent:#35c18f; --line:#e7ecf3;
      --good:#1f7a48; --bad:#b00020; --focus:#1e4cff33;
    }
    *{ box-sizing:border-box }
    html, body{ height:100% }
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family:'Poppins', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height:1.35;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    .shell{ max-width:1100px; margin:0 auto; padding:20px 16px 28px }

    header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px }
    .brand{ font-weight:900; font-size:28px; letter-spacing:.6px; color:var(--ink) }
    .tag{ display:inline-block; font-size:13px; font-weight:600; color:var(--muted); padding:6px 10px; border-radius:999px; background:linear-gradient(180deg,#fff,#f7f9ff); border:1px solid var(--line) }

    /* brighter/larger variant for the role badge */
    .tag.role{
      font-size:16px;
      font-weight:800;
      color:var(--brand);
      padding:8px 14px;
      background:linear-gradient(180deg,#fff,#f0f4ff);
      border-color:#cdd8ff;
      box-shadow:0 8px 22px rgba(30,76,255,.14);
    }

    .card{ position:relative; background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; box-shadow:0 10px 30px rgba(20,32,70,.06); }
    /* add space at the bottom so the floating FAB never overlaps the HUD/timer */
    .mapCard{ padding-bottom:88px; }
    #map{ width:100%; height:min(68vh,560px); border-radius:12px; overflow:hidden }

    .hud{
      display:flex; gap:8px; align-items:center; justify-content:flex-end; margin-top:10px; flex-wrap:wrap;
    }
    .btn{ appearance:none; border:0; border-radius:12px; padding:12px 14px; font-weight:800; color:#fff; background:linear-gradient(135deg,#4facfe,#00f2fe); cursor:pointer; box-shadow:0 4px 12px rgba(79,172,254,.35); }
    .btn.secondary{ background:linear-gradient(135deg,#00f2fe,#4facfe); }
    .pill{ display:inline-block; background:#eef2fa; border:1px solid var(--line); border-radius:999px; padding:8px 12px; font-size:13px; color:#55627a; }
    .notice{ margin-top:8px; font-size:12px; color:#55627a }
    .toast{ position:fixed; left:50%; bottom:20px; transform:translateX(-50%); background:#0e1220; color:#fff; padding:10px 14px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.2); display:none; z-index:99999; font-size:14px; }
    :focus-visible{ outline:3px solid var(--focus); outline-offset:2px; border-radius:8px }

    /* Overlays */
    .overlay{ position:fixed; inset:0; background:rgba(14,18,32,.6); display:none; align-items:center; justify-content:center; padding:16px; z-index:9999; }
    .overlay .sheet{ background:#fff; border:1px solid var(--line); border-radius:16px; padding:18px; max-width:420px; width:min(92vw,420px); box-shadow:0 20px 50px rgba(0,0,0,.25); }
    .overlay h3{ margin:0 0 8px 0; font-size:20px; font-weight:900 }
    .overlay p{ margin:0 0 10px 0; color:var(--muted) }
    .overlay .actions{ display:flex; gap:10px; justify-content:center; margin-top:12px }
    .overlay .actions .btn{ min-width:120px }

    /* Labels for pings/trails */
    .leaflet-tooltip.trailLabel{
      background: rgba(255,255,255,.9);
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 11px;
      color: var(--ink);
      box-shadow: 0 2px 6px rgba(0,0,0,.1);
    }
    /* Tiny seeker name labels */
    .leaflet-tooltip.seekLabel{
      background: rgba(255,255,255,.92);
      border: 1px solid #dde3ef;
      border-radius: 6px;
      padding: 1px 4px;
      font-size: 10px;
      color:#1c2437;
      box-shadow: 0 1px 4px rgba(0,0,0,.08);
    }

    /* Dev-only Testing button + panel */
    .testing-toggle{
      position: fixed; right: 16px; top: 16px; z-index: 9999;
      display:none;
    }
    .testing-panel{
      position: fixed; right: 16px; top: 68px; z-index: 9999; display:none;
      background:#fff; border:1px solid var(--line); border-radius:14px; padding:12px; box-shadow:0 10px 30px rgba(20,32,70,.12);
      width: 280px;
    }
    .testing-panel h4{ margin:8px 0 6px 0; font-size:14px; font-weight:900 }
    .testing-panel .row{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap }
    .testing-panel label{ font-size:12px; color:var(--muted) }
    .testing-panel input[type="number"]{ width:90px; padding:6px 8px; border:1px solid var(--line); border-radius:8px; }
    .testing-panel .fineprint{ font-size:11px; color:var(--muted); margin-top:6px }
    .testing-panel hr{ border:0; border-top:1px solid var(--line); margin:10px 0 6px 0; }

    /* Recenter FAB */
    .mapFab{
      position:absolute; right:16px; bottom:16px; z-index:800;
      padding:10px 12px;
    }

    /* Chat */
    .chat{ margin-top:10px; border:1px solid var(--line); border-radius:12px; background:#fff; overflow:hidden; }
    .chat-log{
      max-height:140px; overflow:auto;
      padding:8px 10px; display:flex; flex-direction:column; gap:6px;
    }
    .chat-msg{ display:flex; gap:8px; align-items:flex-start; font-size:13px; }
    .chat-msg .name{ font-weight:800; color:var(--brand); }
    .chat-msg .text{ color:var(--ink); }
    .chat-msg .time{ font-size:11px; color:var(--muted); margin-left:auto; white-space:nowrap; }
    .chat-form{ display:flex; gap:8px; border-top:1px solid var(--line); padding:8px; }
    .chat-form input{
      flex:1; border:1px solid var(--line); border-radius:8px; padding:8px 10px; font-family:inherit;
      background:#fff;
    }
    /* Mobile: stack chat input and Send button, button below on the left */
    @media (max-width: 640px){
      .chat-form{ flex-direction:column; gap:6px; }
      .chat-form .btn{ align-self:flex-start; }
    }
  </style>
</head>
<body>
  <!-- Dev Testing UI -->
  <button id="btnTesting" class="btn testing-toggle" type="button">Testing</button>
  <div id="testingPanel" class="testing-panel" role="dialog" aria-hidden="true">
    <h4>Seeker Bots</h4>
    <div class="row">
      <label for="botCount">How many:</label>
      <input id="botCount" type="number" min="1" max="8" step="1" value="3" />
    </div>
    <div class="row">
      <button id="btnStartBots" class="btn" type="button">Start bots</button>
      <button id="btnStopBots" class="btn secondary" type="button">Stop</button>
    </div>
    <div class="fineprint">Local-only; not saved to Firestore.</div>

    <hr/>

    <h4>Fugitive Bot</h4>
    <div class="row">
      <label for="fugSpeed">Speed (m/s)</label>
      <input id="fugSpeed" type="number" min="0.3" max="3" step="0.1" value="1.2" />
      <label for="fugPing">Ping (sec)</label>
      <input id="fugPing" type="number" min="5" max="300" step="5" value="60" />
    </div>
    <div class="row">
      <button id="btnStartFug" class="btn" type="button">Start fugitive</button>
      <button id="btnStopFug" class="btn secondary" type="button">Stop</button>
    </div>
    <div class="fineprint">On a fugitive tab, bot pings go to Firestore; seekers can chase.</div>
  </div>

  <div class="shell">
    <header>
      <div>
        <div class="brand">Seekr.run</div>
        <!-- the tag will get the .role class applied once we know the role -->
        <div class="tag" id="gameTag">Loading game...</div>
      </div>
    </header>

    <section class="card mapCard">
      <div id="map" aria-label="Live game map"></div>

      <!-- Recenter FAB (accessibility-friendly) -->
      <button id="btnRecenter" class="btn secondary mapFab" type="button" aria-label="Recenter on my location" title="Recenter on my location">
        Recenter
      </button>

      <div class="hud">
        <span id="timePill" class="pill">Time, syncing…</span>
      </div>
      <div id="hint" class="notice"></div>

      <!-- Global game chat -->
      <div class="chat" aria-label="Game chat">
        <div id="chatLog" class="chat-log" aria-live="polite"></div>
        <form id="chatForm" class="chat-form" autocomplete="off">
          <input id="chatInput" type="text" placeholder="Message everyone…" maxlength="280" aria-label="Chat message" />
          <button class="btn" type="submit" aria-label="Send message">Send</button>
        </form>
      </div>
    </section>
  </div>

  <!-- End-of-game overlay -->
  <div id="end" class="overlay" role="dialog" aria-modal="true" aria-labelledby="endTitle" aria-hidden="true">
    <div class="sheet">
      <h3 id="endTitle">Round ended</h3>
      <p id="endMsg">Thanks for playing.</p>
      <div class="actions">
        <a href="index.html" class="btn secondary">Home</a>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script type="module">
    // Firebase
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot,
      addDoc, collection, query, where, orderBy, limit, serverTimestamp,
      getDocFromServer
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    // Config
    const firebaseConfig = {
      apiKey: "AIzaSyAHJuv3vZH1dMzLkihl6hNQdlHOQNg728M",
      authDomain: "seekr-426ff.firebaseapp.com",
      projectId: "seekr-426ff",
      storageBucket: "seekr-426ff.firebasestorage.app",
      messagingSenderId: "703306109182",
      appId: "1:703306109182:web:afb04af22e974170e555af"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // Track all Firestore unsubscribes
    const unsubs = [];

    // Dev/Test flags
    const url = new URL(location.href);
    const DEV = url.searchParams.get("dev") === "1";
    const BOTS_PARAM = Math.max(0, Math.min(8, Number(url.searchParams.get("bots") || 0)));
    const FUGBOT_PARAM = url.searchParams.get("fugbot") === "1";
    const FUGBOT_SPEED_PARAM = Number(url.searchParams.get("fugs") || NaN);
    const FUGBOT_PING_PARAM  = Number(url.searchParams.get("fugp") || NaN);

    // UI refs
    const gameTag   = document.getElementById('gameTag');
    const timePill  = document.getElementById('timePill');
    const hint      = document.getElementById('hint');
    const toastEl   = document.getElementById('toast');

    const endOverlay= document.getElementById('end');
    const endTitle  = document.getElementById('endTitle');
    const endMsg    = document.getElementById('endMsg');

    // Chat refs
    const chatLog   = document.getElementById('chatLog');
    const chatForm  = document.getElementById('chatForm');
    const chatInput = document.getElementById('chatInput');

    // Testing UI
    const btnTesting = document.getElementById('btnTesting');
    const testingPanel = document.getElementById('testingPanel');
    const botCountInput = document.getElementById('botCount');
    const btnStartBots = document.getElementById('btnStartBots');
    const btnStopBots = document.getElementById('btnStopBots');
    const fugSpeedInput = document.getElementById('fugSpeed');
    const fugPingInput  = document.getElementById('fugPing');
    const btnStartFug   = document.getElementById('btnStartFug');
    const btnStopFug    = document.getElementById('btnStopFug');

    if (DEV) {
      btnTesting.style.display = 'inline-block';
      btnTesting.addEventListener('click', () => {
        testingPanel.style.display = testingPanel.style.display === 'none' || testingPanel.style.display === '' ? 'block' : 'none';
      });
    }

    // Map + game state
    let map, myMarker, extractMarker;
    let role = null;
    let myName = "Player";
    let uncertaintyM = 50;
    let tagMeters = 2;
    let tickId = null;
    let revealToastShown = false;
    let geoWatchId = null;

    let areaCircle = null;
    let areaCenterLL = null;
    let areaRadiusM = 0;
    let zoneFitDone = false;

    // Presence / trail
    let lastCoords = null;
    let presenceTimer = null;
    let seekersNow = [];   // live seekers from Firestore
    let secretLL = null;
    let gameEnded = false;

    // Fugitive pings (real)
    let autoPingId = null;
    let autoPingEveryMs = 0;
    let didInitialAutoPing = false;

    // Seeker trail (fugitive)
    const trailColor = '#ff9500'; // orange
    let trailLayer = null;
    let trailLine = null;
    let trailListenerStarted = false;
    let currentFugitiveUid = null;

    // NEW: pursuit target for bots
    let lastFugPingLL = null;

    // Seeker-to-seeker layer
    let seekersLayer = null;
    const seekersMarkers = new Map(); // uid -> L.circleMarker
    let seekersRenderTimer = null;
    const SEEKERS_RENDER_MS = 60000;
    const seekersLive = new Map();   // uid -> {lat,lng,updatedAt}
    const memberNames = new Map();   // uid -> display name

    // --- Dynamic extraction radius controls ---
    let currentEndMs = 0;
    let extractionBaseM = 30;         // default win radius
    let extractionFinalM = 50;        // radius during the final window
    let extractionBoostMin = 2;       // minutes left when we boost the radius

    // --- Local SEEKER bots (with pursuit) ---
    let botsLayer = null;
    let botTimer = null;
    const bots = [];
    function rand(min, max){ return min + Math.random() * (max - min); }
    const R = 6371000;
    function llFromOffset(lat, lng, dx, dy){
      const dLat = (dy / R) * (180/Math.PI);
      const dLng = (dx / (R * Math.cos(lat * Math.PI/180))) * (180/Math.PI);
      return [lat + dLat, lng + dLng];
    }
    function clampToZone(lat, lng){
      if (!areaCenterLL || !areaRadiusM) return [lat, lng];
      const d = map.distance([lat,lng], areaCenterLL);
      if (d <= areaRadiusM) return [lat, lng];
      const bearing = Math.atan2(areaCenterLL.lng - lng, areaCenterLL.lat - lat);
      const over = d - areaRadiusM + 5;
      const [nl, ng] = llFromOffset(lat, lng, Math.sin(bearing)*(-over), Math.cos(bearing)*(-over));
      return [nl, ng];
    }
    function spawnBots(n){
      if (!DEV || !areaCenterLL || !areaRadiusM) return;
      if (!botsLayer) botsLayer = L.layerGroup().addTo(map);
      stopBots();
      const names = Array.from({length:n}, (_,i)=>`Bot ${i+1}`);
      for (let i=0;i<n;i++){
        const u = Math.random(), v = Math.random();
        const r = Math.sqrt(u) * (areaRadiusM * 0.85);
        const th = 2 * Math.PI * v;
        const dx = Math.cos(th) * r, dy = Math.sin(th) * r;
        const [lat, lng] = llFromOffset(areaCenterLL.lat, areaCenterLL.lng, dx, dy);
        const marker = L.circleMarker([lat, lng], {
          radius: 5, weight: 2, color: '#000000', fillColor: '#000000', fillOpacity: 0.9
        }).addTo(botsLayer).bindTooltip(names[i], { permanent:true, direction:"top", offset:[0,-8], opacity:0.95, className:"seekLabel" });
        bots.push({ id:`bot${i+1}`, name:names[i], lat, lng, headingRad: rand(0, Math.PI*2), speedMps: rand(0.9, 1.7), marker });
      }
      botTimer = setInterval(stepBots, 2000);
      renderSeekersNowPlus();
    }
    function stepBots(){
      if (!bots.length || !areaCenterLL) return;
      const dt = 2;
      for (const b of bots){
        if (lastFugPingLL){
          const dirToFug = Math.atan2(lastFugPingLL.lng - b.lng, lastFugPingLL.lat - b.lat);
          b.headingRad = b.headingRad*0.35 + dirToFug*0.65 + rand(-0.18, 0.18);
        } else {
          b.headingRad += rand(-0.35, 0.35);
          const distFromCenter = map.distance([b.lat,b.lng], areaCenterLL);
          if (distFromCenter > areaRadiusM * 0.8){
            const dirToCenter = Math.atan2(areaCenterLL.lng - b.lng, areaCenterLL.lat - b.lat);
            b.headingRad = b.headingRad*0.4 + dirToCenter*0.6;
          }
        }
        const step = b.speedMps * dt;
        const dx = Math.sin(b.headingRad) * step, dy = Math.cos(b.headingRad) * step;
        let [lat, lng] = llFromOffset(b.lat, b.lng, dx, dy);
        [lat, lng] = clampToZone(lat, lng);
        b.lat = lat; b.lng = lng;
        if (b.marker) b.marker.setLatLng([lat,lng]);
      }
      renderSeekersNowPlus();
      if (seekersLayer) { renderSeekersImmediate(); }
    }
    function stopBots(){
      if (botTimer){ clearInterval(botTimer); botTimer = null; }
      if (botsLayer){ botsLayer.clearLayers(); }
      bots.length = 0;
      renderSeekersNowPlus();
      if (seekersLayer) { renderSeekersImmediate(); }
    }
    function renderSeekersNowPlus(){
      if (role !== "fugitive") return;
      const localBots = bots.map(b => ({ lat:b.lat, lng:b.lng }));
      seekersNowPlus = seekersNow.concat(localBots);
    }
    let seekersNowPlus = [];

    // --- Local FUGITIVE bot (heads to extraction after reveal) ---
    let fugLayer = null;
    let fugMoveTimer = null;
    let fugPingTimer = null;
    let fug = null; // {lat,lng,headingRad,speedMps, marker, wanderTo}

    function ensureTrailLayer(){
      if (!trailLayer) trailLayer = L.layerGroup().addTo(map);
      if (!trailLine)  trailLine  = L.polyline([], { color:'#ff9500', weight:2, dashArray:'4,6', opacity:0.95 }).addTo(trailLayer);
    }

    function addLocalFugitivePing(lat, lng, when = new Date()){
      ensureTrailLayer();
      trailLine.addLatLng([lat, lng]);
      const mk = L.circleMarker([lat,lng], { radius:5, weight:2, color:'#ff9500', fillColor:'#ff9500', fillOpacity:0.9 }).addTo(trailLayer);
      if (uncertaintyM > 0){
        L.circle([lat,lng], { radius: uncertaintyM, color:'#ff9500', weight:1, opacity:0.4, fillOpacity:0.08 }).addTo(trailLayer);
      }
      const hh = String(when.getHours()).padStart(2,'0');
      const mm = String(when.getMinutes()).padStart(2,'0');
      mk.bindTooltip(`${hh}:${mm}`, { permanent:true, direction:"top", offset:[0,-8], opacity:0.95, className:"trailLabel" });
    }

    function startFugitiveBot(opts = {}){
      if (!DEV) return;
      if (!areaCenterLL || !areaRadiusM){ toast("Fugitive bot needs the zone loaded first."); return; }
      stopFugitiveBot();

      const speed = Number.isFinite(opts.speedMps) ? opts.speedMps : Number(fugSpeedInput.value || 1.2);
      const pingS = Number.isFinite(opts.pingSec) ? opts.pingSec : Number(fugPingInput.value || 60);

      if (!fugLayer) fugLayer = L.layerGroup().addTo(map);

      const dx0 = rand(-areaRadiusM*0.2, areaRadiusM*0.2);
      const dy0 = rand(-areaRadiusM*0.2, areaRadiusM*0.2);
      const [lat0, lng0] = llFromOffset(areaCenterLL.lat, areaCenterLL.lng, dx0, dy0);

      const marker = L.circleMarker([lat0,lng0], { radius:7, weight:3, color:'#ff9500', fillColor:'#ffb94e', fillOpacity:0.95 })
        .addTo(fugLayer)
        .bindTooltip('Fugitive Bot', { permanent:true, direction:"top", offset:[0,-10], opacity:0.95, className:"seekLabel" });

      fug = { lat:lat0, lng:lng0, headingRad: rand(0, Math.PI*2), speedMps: speed, marker, wanderTo: null };

      fugMoveTimer = setInterval(()=>{
        if (!fug || !areaCenterLL) return;

        const hasTarget = !!secretLL;
        let target = null;

        if (hasTarget){
          target = secretLL;
        } else {
          if (!fug.wanderTo || map.distance([fug.lat,fug.lng], fug.wanderTo) < 15){
            const u = Math.random(), v = Math.random();
            const r = Math.sqrt(u) * (areaRadiusM * 0.85);
            const th = 2*Math.PI*v;
            const dx = Math.cos(th)*r, dy = Math.sin(th)*r;
            const [wl, wg] = llFromOffset(areaCenterLL.lat, areaCenterLL.lng, dx, dy);
            fug.wanderTo = L.latLng(wl, wg);
          }
          target = fug.wanderTo;
        }

        const dirToT = Math.atan2(target.lng - fug.lng, target.lat - fug.lat);
        fug.headingRad = fug.headingRad*0.4 + dirToT*0.6 + rand(-0.12, 0.12);

        const step = fug.speedMps * 1.5;
        const dx = Math.sin(fug.headingRad) * step, dy = Math.cos(fug.headingRad) * step;
        let [lat, lng] = llFromOffset(fug.lat, fug.lng, dx, dy);
        [lat, lng] = clampToZone(lat, lng);
        fug.lat = lat; fug.lng = lng;
        fug.marker.setLatLng([lat,lng]);

        if (role === "seeker" && lastCoords){
          const d = map.distance([lastCoords.latitude,lastCoords.longitude], [lat,lng]);
          if (d <= tagMeters){ toast("You tagged the fugitive bot"); }
        }
      }, 1500);

      ensureTrailLayer();
      addLocalFugitivePing(fug.lat, fug.lng, new Date());

      fugPingTimer = setInterval(async ()=>{
        if (!fug) return;
        const now = new Date();

        if (role === "fugitive"){
          try{
            const uid = auth.currentUser?.uid || null;
            await addDoc(collection(db, "games", code, "pings"), {
              lat: fug.lat, lng: fug.lng, role: "fugitive", uid, reason: "bot", createdAt: serverTimestamp()
            });
          }catch(e){ console.warn("fugitive bot ping failed", e); }
        }

        addLocalFugitivePing(fug.lat, fug.lng, now);
        lastFugPingLL = L.latLng(fug.lat, fug.lng);
      }, Math.max(5, pingS) * 1000);

      toast(`Fugitive bot started (${speed.toFixed(1)} m/s, pings every ${Math.round(pingS)}s).`);
    }

    function stopFugitiveBot(){
      if (fugMoveTimer){ clearInterval(fugMoveTimer); fugMoveTimer = null; }
      if (fugPingTimer){ clearInterval(fugPingTimer); fugPingTimer = null; }
      if (fugLayer){ fugLayer.clearLayers(); }
      fug = null;
    }

    // Testing UI wiring
    if (DEV){
      btnStartBots.addEventListener('click', () => {
        const n = Math.max(1, Math.min(8, Number(botCountInput.value || 3)));
        if (!areaCenterLL || !areaRadiusM){ toast("Bots need the zone to load first."); return; }
        spawnBots(n);
        toast(`Started ${n} bot${n>1?'s':''}.`);
      });
      btnStopBots.addEventListener('click', () => { stopBots(); toast("Bots stopped."); });

      btnStartFug.addEventListener('click', () => { startFugitiveBot(); });
      btnStopFug.addEventListener('click', () => { stopFugitiveBot(); toast("Fugitive bot stopped."); });
    }

    // Code
    const code = url.searchParams.get("code")?.toUpperCase() || "";

    // Map init (prefer Canvas renderer)
    function initMap(){
      map = L.map('map', { zoomControl:true, attributionControl:false, preferCanvas:true });
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
      map.setView([51.505, -0.09], 15);
    }
    initMap();

    // Recenter FAB
    document.getElementById('btnRecenter')?.addEventListener('click', () => {
      if (lastCoords && map) {
        map.setView([lastCoords.latitude, lastCoords.longitude], Math.max(map.getZoom(), 16));
      } else {
        toast("Waiting for your location…");
      }
    });

    startGeoWatch();

    function updateMyMarker(lat, lng, recenter = false){
      const ll = [lat, lng];
      if (!myMarker) {
        myMarker = L.circleMarker(ll, { radius:8, weight:3, color:'#1e4cff', fillColor:'#1e4cff', fillOpacity:.35 }).addTo(map);
      } else {
        myMarker.setLatLng(ll);
      }
      if (recenter && map) map.setView(ll, Math.max(map.getZoom(), 16));
    }

    function toast(t){
      toastEl.textContent = t;
      toastEl.style.display = 'block';
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(() => toastEl.style.display = 'none', 2200);
    }

    function showEndOverlay(winner, reason){
      endTitle.textContent = winner === "fugitive" ? "Fugitive Wins!" :
                             winner === "seeker"   ? "Seekers Win!"  : "Round Ended";
      endMsg.textContent = winner === "fugitive"
        ? (reason === "extract" ? "The fugitive reached extraction." : "The fugitives escaped.")
        : (winner === "seeker" ? "A seeker tagged the fugitive." : "Game over.");
      endOverlay.style.display = 'flex';
      endOverlay.setAttribute('aria-hidden', 'false');
    }

    async function endGame(winner, reason = "manual"){
      if (gameEnded) return;
      gameEnded = true;
      try{
        await setDoc(doc(db, "games", code), {
          status: "ended",
          winner,
          endReason: reason,
          endedAt: serverTimestamp()
        }, { merge:true });
      }catch(e){
        console.error("endGame failed", e);
        gameEnded = false;
      }
    }

    // Save a ping for the current player (used by fugitive auto-ping & round start)
    async function saveCurrentPing(reason = "manual"){
      try{
        if (!lastCoords || !code) return;
        const uid = auth.currentUser?.uid || null;
        await addDoc(collection(db, "games", code, "pings"), {
          lat: lastCoords.latitude,
          lng: lastCoords.longitude,
          role, uid, reason,
          createdAt: serverTimestamp()
        });
        // NOTE: we intentionally do NOT render the breadcrumb for fugitives,
        // so only seekers see the trail.
        if (role === "fugitive"){
          lastFugPingLL = L.latLng(lastCoords.latitude, lastCoords.longitude);
        }
      }catch(e){ console.warn("saveCurrentPing failed", e); }
    }

    // Location
    function startGeoWatch(){
      if (geoWatchId) return;

      const isLocalhost = ['localhost', '127.0.0.1', '::1'].includes(location.hostname);
      if (!window.isSecureContext && !isLocalhost) { toast('Location needs HTTPS or localhost.'); return; }
      if (!('geolocation' in navigator)){ toast('Geolocation not available in this browser.'); return; }

      navigator.geolocation.getCurrentPosition(
        pos => { lastCoords = pos.coords; updateMyMarker(pos.coords.latitude, pos.coords.longitude, true); },
        err => { console.warn('getCurrentPosition error', err); toast('Please allow location to see your dot.'); },
        { enableHighAccuracy:true, maximumAge:5000, timeout:15000 }
      );

      geoWatchId = navigator.geolocation.watchPosition(
        pos => {
          lastCoords = pos.coords;
          updateMyMarker(pos.coords.latitude, pos.coords.longitude, false);
          maybeCheckExtractionWin(pos.coords);
          maybeCheckTaggedBySeeker(pos.coords);
        },
        err => {
          console.warn('watchPosition error', err);
          if (!startGeoWatch._errShown){
            toast('Lost location updates. Move outside or check permissions.');
            startGeoWatch._errShown = true;
            setTimeout(()=> startGeoWatch._errShown = false, 8000);
          }
        },
        { enableHighAccuracy:true, maximumAge:5000, timeout:15000 }
      );
    }

    async function cleanupPresence(){
      try {
        const uid = auth.currentUser?.uid;
        if (uid && role === "seeker") {
          await setDoc(
            doc(db, "games", code, "presence", uid),
            { role: "seeker", offline: true, lat: null, lng: null, updatedAt: serverTimestamp() },
            { merge: true }
          );
        }
      } catch {}
    }

    function stopAllRealtime(){
      // intervals/timers
      if (tickId) { clearInterval(tickId); tickId = null; }
      if (autoPingId) { clearInterval(autoPingId); autoPingId = null; }
      if (presenceTimer) { clearInterval(presenceTimer); presenceTimer = null; }
      if (seekersRenderTimer) { clearInterval(seekersRenderTimer); seekersRenderTimer = null; }
      if (botTimer) { clearInterval(botTimer); botTimer = null; }
      if (fugMoveTimer) { clearInterval(fugMoveTimer); fugMoveTimer = null; }
      if (fugPingTimer) { clearInterval(fugPingTimer); fugPingTimer = null; }

      // geolocation
      if (geoWatchId) { navigator.geolocation.clearWatch(geoWatchId); geoWatchId = null; }

      // Firestore listeners
      unsubs.splice(0).forEach(u => { try{ u(); }catch{} });
    }

    function maybeCheckExtractionWin(coords){
      if (role !== "fugitive" || !secretLL || gameEnded) return;
      const d = map.distance([coords.latitude, coords.longitude], secretLL);

      // Dynamic extraction radius: base, with a boost in the final window
      let radius = extractionBaseM;
      if (currentEndMs && extractionBoostMin > 0) {
        const leftMs = currentEndMs - Date.now();
        if (leftMs <= extractionBoostMin * 60000) {
          radius = Math.max(radius, extractionFinalM);
        }
      }

      if (d <= radius){
        toast("You reached extraction");
        endGame("fugitive", "extract");
      }
    }

    function maybeCheckTaggedBySeeker(coords){
      if (role !== "fugitive" || gameEnded) return;
      const me = L.latLng(coords.latitude, coords.longitude);
      const pool = DEV ? seekersNowPlus : seekersNow;
      for (const s of pool){
        if (typeof s.lat !== "number" || typeof s.lng !== "number") continue;
        const d = map.distance(me, [s.lat, s.lng]);
        if (d <= tagMeters){
          toast("A seeker tagged you");
          endGame("seeker", "tag");
          break;
        }
      }
    }

    // Seeker trail (fugitive path)
    function startSeekerTrail(){
      if (trailLayer) return;
      ensureTrailLayer();
      const qTrail = query(collection(db, "games", code, "pings"), where("role", "==", "fugitive"), orderBy("createdAt", "asc"));
      const u = onSnapshot(qTrail, snap => {
        snap.docChanges().forEach(ch => {
          if (ch.type !== "added") return;
          const p = ch.doc.data();
          if (currentFugitiveUid && p.uid !== currentFugitiveUid) return;
          if (typeof p.lat !== "number" || typeof p.lng !== "number") return;
          addLocalFugitivePing(p.lat, p.lng, p.createdAt?.toDate?.() || new Date());
          lastFugPingLL = L.latLng(p.lat, p.lng);
        });
      }, err => console.error("trail listener error", err));
      unsubs.push(u);
    }

    function startSecretListener(){
      const secretRef = doc(db, "games", code, "private", "secret");
      const u = onSnapshot(secretRef, snap => {
        if (!snap.exists() || extractMarker) return;
        const { lat, lng } = snap.data() || {};
        if (typeof lat !== "number" || typeof lng !== "number") return;
        extractMarker = L.circleMarker([lat, lng], { radius: 8, weight: 3, color: '#ffffff', fillColor: '#ff3b30', fillOpacity: 0.95 }).addTo(map);
        secretLL = L.latLng(lat, lng);
        map.setView([lat, lng], Math.max(map.getZoom(), 16));
        toast("Extraction revealed, get within range to win.");
      }, err => console.error("Secret listener error", err));
      unsubs.push(u);
    }

    // Seekers publish their own presence (5s cadence)
    function startPresencePublisher(){
      if (presenceTimer || role !== "seeker" || gameEnded) return;
      const myId = auth.currentUser?.uid;
      if (!myId) return;
      const presRef = doc(db, "games", code, "presence", myId);
      const publish = async () => {
        if (!lastCoords || gameEnded) return;
        try{
          await setDoc(presRef, { role: "seeker", lat: lastCoords.latitude, lng: lastCoords.longitude, updatedAt: serverTimestamp() }, { merge:true });
        }catch(e){ console.warn("presence write failed", e); }
      };
      publish();
      presenceTimer = setInterval(publish, 5000);
    }

    // Fugitives read seekers for tag detection
    function startReadingSeekersForFugitive(){
      const qSeekers = query(collection(db, "games", code, "presence"), where("role", "==", "seeker"));
      const u = onSnapshot(qSeekers, snap => {
        seekersNow = snap.docs.map(d => d.data()).filter(d => typeof d.lat === "number" && typeof d.lng === "number");
        renderSeekersNowPlus();
      }, err => console.error("presence read error", err));
      unsubs.push(u);
    }

    // Seekers see other seekers (and we inject bots locally)
    function startSeekersVisualizer(){
      if (seekersLayer) return;
      seekersLayer = L.layerGroup().addTo(map);
      const myId = auth.currentUser?.uid;

      const u1 = onSnapshot(collection(db, "games", code, "members"), snap => {
        snap.forEach(docu => {
          const d = docu.data() || {};
          const nm = d.name || d.displayName || d.nickname || (d.role === 'fugitive' ? 'Fugitive' : 'Seeker');
          memberNames.set(docu.id, String(nm));
        });
      });
      unsubs.push(u1);

      const qSeekers = query(collection(db, "games", code, "presence"), where("role", "==", "seeker"));
      const u2 = onSnapshot(qSeekers, snap => {
        seekersLive.clear();
        snap.forEach(docu => {
          const d = docu.data() || {};
          if (typeof d.lat === "number" && typeof d.lng === "number") {
            seekersLive.set(docu.id, { lat:d.lat, lng:d.lng, updatedAt:d.updatedAt });
          }
        });
        // Render immediately on every snapshot (fixes one-way visibility)
        renderSeekersImmediate();
      });
      unsubs.push(u2);

      // Smaller fallback repaint
      if (!seekersRenderTimer) seekersRenderTimer = setInterval(renderSeekersImmediate, 15000);
    }
    function renderSeekersImmediate(){
      if (!seekersLayer) return;
      seekersLayer.clearLayers();
      seekersMarkers.clear();
      const myId = auth.currentUser?.uid;
      seekersLive.forEach((val, uid) => {
        if (uid === myId) return;
        const mk = L.circleMarker([val.lat,val.lng], { radius:5, weight:2, color:'#000', fillColor:'#000', fillOpacity:0.9 }).addTo(seekersLayer);
        const name = memberNames.get(uid) || 'Seeker';
        mk.bindTooltip(name, { permanent:true, direction:"top", offset:[0,-8], opacity:0.95, className:"seekLabel" });
        seekersMarkers.set(uid, mk);
      });
      if (DEV && bots.length){
        for (const b of bots){
          L.circleMarker([b.lat,b.lng], { radius:5, weight:2, color:'#000', fillColor:'#000', fillOpacity:0.9 })
            .addTo(seekersLayer).bindTooltip(b.name, { permanent:true, direction:"top", offset:[0,-8], opacity:0.95, className:"seekLabel" });
        }
      }
    }

    // --- Time helpers (single source of truth) ---
    function toMs(v){
      if (!v) return 0;
      if (typeof v === "number") return v < 1e12 ? v * 1000 : v;
      if (typeof v === "string") { const t = Date.parse(v); return Number.isNaN(t) ? 0 : t; }
      if (typeof v === "object" && typeof v.toMillis === "function") return v.toMillis();
      if (typeof v === "object" && typeof v.toDate === "function") return v.toDate().getTime();
      if (typeof v === "object" && typeof v.seconds === "number") {
        return v.seconds * 1000 + Math.floor((v.nanoseconds || 0) / 1e6);
      }
      return 0;
    }

    // NEW: long-game formatter
    function formatLeft(leftMs, useHMS){
      const totalSec = Math.max(0, Math.floor(leftMs / 1000));
      const s = totalSec % 60;
      const m = Math.floor(totalSec / 60) % 60;
      const h = Math.floor(totalSec / 3600);
      if (useHMS) {
        return `${h}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
      } else {
        const mm = Math.floor(totalSec / 60);
        return `${mm}:${String(s).padStart(2,"0")}`;
      }
    }

    function computeTimes(g){
      const rulesMinutes = Number(g?.rules?.game_minutes || 0);
      const durationMs   = Number(g?.durationMs || (rulesMinutes > 0 ? rulesMinutes * 60000 : 0));
      const startMs = toMs(g?.startsAt) || 0;
      let endMs   = toMs(g?.endsAt)   || 0;
      if ((!endMs && startMs && durationMs) || (startMs && endMs && (endMs - startMs) < Math.min(120000, durationMs * 0.1))) {
        endMs = startMs + durationMs;
      }
      let revealAtMs = toMs(g?.revealAt) || 0;
      const revealRemainMin = Number(g?.rules?.reveal_minutes_remaining || 0);
      if (!revealAtMs && endMs && revealRemainMin > 0) {
        revealAtMs = endMs - revealRemainMin * 60000;
      }
      return { startMs, endMs, revealAtMs, durationMs };
    }

    // UPDATED: H:MM:SS for 60+ minute games
    function startCountdown({startMs, endMs, revealAtMs}){
      if (tickId) { clearInterval(tickId); tickId = null; }
      const now = Date.now();
      if (!startMs || !endMs || endMs <= now) { timePill.textContent = "Time, waiting"; return; }

      const totalMs = (endMs && startMs) ? (endMs - startMs) : 0;
      const useHMS = totalMs >= 60 * 60 * 1000; // 60+ minutes

      const tick = () => {
        const n = Date.now();
        if (n < startMs){
          const until = startMs - n;
          const m = Math.floor(until / 60000), s = String(Math.floor((until % 60000) / 1000)).padStart(2, "0");
          timePill.textContent = `Starts in, ${m}:${s}`;
          return;
        }
        const left = Math.max(0, endMs - n);
        timePill.textContent = `Time, ${formatLeft(left, useHMS)}`;
        if (role === "fugitive" && revealAtMs && n >= revealAtMs && !extractMarker) startSecretListener();
        if (role === "seeker" && revealAtMs && n >= revealAtMs && !revealToastShown) { toast("Extraction location has been disclosed to fugitives."); revealToastShown = true; }
        if (left === 0) { clearInterval(tickId); tickId = null; }
      };
      tick();
      tickId = setInterval(tick, 1000);
    }

    // --- Chat ---
    function startChat(){
      if (!code) return;
      const qChat = query(collection(db, "games", code, "chat"), orderBy("createdAt", "asc"), limit(200));
      const u = onSnapshot(qChat, snap => {
        // Rebuild quickly for simplicity/ordering
        chatLog.innerHTML = '';
        const frag = document.createDocumentFragment();
        snap.forEach(docu => {
          const d = docu.data() || {};
          if (typeof d.text !== "string") return;
          frag.appendChild(renderChatMsg(d));
        });
        chatLog.appendChild(frag);
        chatLog.scrollTop = chatLog.scrollHeight;
      }, err => console.error("chat listener error", err));
      unsubs.push(u);

      chatForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const txt = (chatInput.value || '').trim();
        if (!txt) return;
        chatInput.value = '';
        try{
          const uid = auth.currentUser?.uid || null;
          await addDoc(collection(db, "games", code, "chat"), {
            uid, name: myName, role, text: txt, createdAt: serverTimestamp()
          });
        }catch(e){ console.warn("chat send failed", e); toast("Could not send message"); }
      });
    }
    function renderChatMsg(d){
      const row = document.createElement('div');
      row.className = 'chat-msg';
      const name = document.createElement('span');
      name.className = 'name';
      name.textContent = d.name || 'Player';
      const text = document.createElement('span');
      text.className = 'text';
      text.textContent = d.text; // safe: no HTML injection
      const time = document.createElement('span');
      time.className = 'time';
      const when = d.createdAt?.toDate?.() || new Date();
      const hh = String(when.getHours()).padStart(2,'0');
      const mm = String(when.getMinutes()).padStart(2,'0');
      time.textContent = `${hh}:${mm}`;
      row.appendChild(name);
      row.appendChild(text);
      row.appendChild(time);
      return row;
    }

    // Auth + wire up
    onAuthStateChanged(auth, async user => {
      if (!user) return;
      if (!code) { toast("Missing code in URL"); return; }

      // Read my membership to infer role (created via lobby)
      const memberRef = doc(db, "games", code, "members", user.uid);
      let storedRole = null;
      try {
        const m = await getDoc(memberRef);
        if (m.exists()){
          const md = m.data() || {};
          storedRole = md.role || null;
          myName = String(md.name || md.displayName || md.nickname || "Player");
        }
      } catch (e) { console.warn("Cannot read membership; open the lobby first to join.", e); }
      role = storedRole || null;
      if (!role) { location.replace(`lobby.html?code=${encodeURIComponent(code)}`); return; }

      // Apply bigger/brighter role tag and grammar ("a Seeker"/"a Fugitive")
      const roleLabel = role === "seeker" ? "a Seeker" : (role === "fugitive" ? "a Fugitive" : role);
      gameTag.textContent = "Game " + code + " • You are " + roleLabel;
      gameTag.classList.add("role");

      if (DEV) { btnTesting.style.display = 'inline-block'; testingPanel.style.display = 'block'; }

      if (role === "seeker") { startPresencePublisher(); startSeekersVisualizer(); }
      if (role === "fugitive") { startReadingSeekersForFugitive(); }

      // Start chat after we know who we are
      startChat();

      const gameRef = doc(db, "games", code);

      // PRIME from server to avoid 00:01 drift
      try {
        const srv = await getDocFromServer(gameRef);
        if (srv.exists()) {
          const times = computeTimes(srv.data());
          currentEndMs = times.endMs || 0;  // store for dynamic extraction radius
          startCountdown(times);
        }
      } catch (e) { console.warn("Server prime failed:", e); }

      // Live updates
      const uGame = onSnapshot(
        gameRef,
        snap => {
          if (!snap.exists()) { hint.textContent = "Game not found"; stopAllRealtime(); return; }
          const g = snap.data();

          if (g.status === "lobby") { toast("Waiting in lobby…"); location.replace(`lobby.html?code=${encodeURIComponent(code)}`); return; }

          // Fugitive changes reset trail
          const nextFug = g.fugitiveUid || null;
          const fugChanged = nextFug !== currentFugitiveUid;
          currentFugitiveUid = nextFug;
          if (role === "seeker" && !trailListenerStarted) { startSeekerTrail(); trailListenerStarted = true; }
          if (role === "seeker" && fugChanged && trailLayer && trailLine) {
            trailLayer.clearLayers(); trailLine = L.polyline([], { color:trailColor, weight:2, dashArray:'4,6', opacity:0.95 }).addTo(trailLayer);
          }

          if (g.status === "ended"){ gameEnded = true; stopAllRealtime(); timePill.textContent = "Time, round ended"; showEndOverlay(g.winner || "unknown", g.endReason || ""); return; }

          // Zone
          const z = g.zone || null;
          const hasCenter = z && z.center && typeof z.center.lat === "number" && typeof z.center.lng === "number";
          const radiusKm = z && (typeof z.radius_km === "number" ? z.radius_km : (typeof z.radius_m === "number" ? z.radius_m/1000 : null));
          if (hasCenter && typeof radiusKm === "number" && Number.isFinite(radiusKm)) {
            areaCenterLL = L.latLng(z.center.lat, z.center.lng);
            areaRadiusM = Math.max(50, Math.round(radiusKm * 1000));
            if (!areaCircle) {
              areaCircle = L.circle(areaCenterLL, { radius: areaRadiusM, color:"#1e4cff", weight:2, fillColor:"#1e4cff", fillOpacity:0.08, dashArray:"4,6" }).addTo(map);
              if (!zoneFitDone && !myMarker) { map.fitBounds(areaCircle.getBounds()); zoneFitDone = true; }
            } else { areaCircle.setLatLng(areaCenterLL); areaCircle.setRadius(areaRadiusM); }

            // auto-start bots from URL when zone known
            if (DEV && BOTS_PARAM > 0 && bots.length === 0) { botCountInput.value = String(BOTS_PARAM); spawnBots(BOTS_PARAM); toast(`Auto-started ${BOTS_PARAM} bot${BOTS_PARAM>1?'s':''}.`); }
            if (DEV && FUGBOT_PARAM && !fug) {
              if (Number.isFinite(FUGBOT_SPEED_PARAM)) fugSpeedInput.value = String(FUGBOT_SPEED_PARAM);
              if (Number.isFinite(FUGBOT_PING_PARAM))  fugPingInput.value  = String(FUGBOT_PING_PARAM);
              startFugitiveBot({ speedMps:Number(fugSpeedInput.value), pingSec:Number(fugPingInput.value) });
            }
          }

          // Rules
          const cfg = g.lobbyConfig || {};
          uncertaintyM = Number(cfg.uncertaintyM ?? g.rules?.uncertainty_m ?? 50);
          tagMeters    = Number(g.rules?.tag_meters ?? 2);

          // NEW: extraction win radii (with sensible defaults)
          extractionBaseM    = Number(g.rules?.extraction_radius_m ?? 30);
          extractionFinalM   = Number(g.rules?.extraction_final_radius_m ?? extractionBaseM);
          extractionBoostMin = Number(g.rules?.extraction_boost_minutes ?? 2);

          // Fugitive auto pings (real player)
          const pingMinutes = Number(g.rules?.ping_minutes || 0);
          const desiredMs = pingMinutes > 0 ? pingMinutes * 60 * 1000 : 0;
          if (role === "fugitive") {
            if (autoPingId && autoPingEveryMs !== desiredMs) { clearInterval(autoPingId); autoPingId = null; }
            if (!autoPingId && desiredMs > 0) {
              autoPingEveryMs = desiredMs;
              didInitialAutoPing = false;
              if (lastCoords) saveCurrentPing("interval-start").catch(()=>{});
              autoPingId = setInterval(() => saveCurrentPing("interval"), desiredMs);
            }
          } else { if (autoPingId) { clearInterval(autoPingId); autoPingId = null; } }

          // Times & countdown
          const times = computeTimes(g);
          currentEndMs = times.endMs || 0; // store for dynamic extraction radius
          if (role === "fugitive" && g.status === "live" && lastCoords && !didInitialAutoPing) { saveCurrentPing("round-start").catch(()=>{}); didInitialAutoPing = true; }
          if (role === "fugitive" && times.revealAtMs && Date.now() >= times.revealAtMs && !extractMarker) { startSecretListener(); }
          startCountdown(times);
        },
        err => { console.error("onSnapshot error for games/%s", code, err); hint.textContent = "Cannot read game, check Firestore rules."; stopAllRealtime(); }
      );
      unsubs.push(uGame);
    });

    signInAnonymously(auth).catch(console.error);

    // Visibility/pagetear-down: presence cleanup for seekers
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) cleanupPresence().catch(()=>{});
    });
    window.addEventListener('pagehide', () => { cleanupPresence(); });
    window.addEventListener('beforeunload', () => {
      cleanupPresence();
      stopAllRealtime();
      stopFugitiveBot();
      stopBots();
    });
  </script>
</body>
</html>
