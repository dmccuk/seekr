<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Seekr.run, Gameplay</title>
  <link rel="icon" type="image/x-icon" href="assets/seekr-favicon.ico" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800;900&display=swap" rel="stylesheet">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <style>
    :root{
      --ink:#0e1220; --muted:#55627a; --bg:#f6f8fc; --card:#ffffff;
      --brand:#1e4cff; --accent:#35c18f; --line:#e7ecf3;
      --good:#1f7a48; --bad:#b00020; --focus:#1e4cff33;
    }
    *{ box-sizing:border-box }
    html, body{ height:100% }
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family:'Poppins', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height:1.35;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    .shell{ max-width:1100px; margin:0 auto; padding:20px 16px 28px }

    header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px }
    .brand{ font-weight:900; font-size:28px; letter-spacing:.6px; color:var(--ink) }
    .tag{ display:inline-block; font-size:13px; font-weight:600; color:var(--muted); padding:6px 10px; border-radius:999px; background:linear-gradient(180deg,#fff,#f7f9ff); border:1px solid var(--line) }

    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; box-shadow:0 10px 30px rgba(20,32,70,.06); }
    #map{ width:100%; height:min(68vh,560px); border-radius:12px; overflow:hidden }

    .hud{
      display:flex; gap:8px; align-items:center; justify-content:flex-end; margin-top:10px; flex-wrap:wrap;
    }
    .btn{ appearance:none; border:0; border-radius:12px; padding:12px 14px; font-weight:800; color:#fff; background:linear-gradient(135deg,#4facfe,#00f2fe); cursor:pointer; box-shadow:0 4px 12px rgba(79,172,254,.35); }
    .btn.secondary{ background:linear-gradient(135deg,#00f2fe,#4facfe); }
    .pill{ display:inline-block; background:#eef2fa; border:1px solid var(--line); border-radius:999px; padding:8px 12px; font-size:13px; color:#55627a; }
    .notice{ margin-top:8px; font-size:12px; color:#55627a }
    .toast{ position:fixed; left:50%; bottom:20px; transform:translateX(-50%); background:#0e1220; color:#fff; padding:10px 14px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.2); display:none; z-index:99999; font-size:14px; }
    :focus-visible{ outline:3px solid var(--focus); outline-offset:2px; border-radius:8px }

    /* Overlays */
    .overlay{ position:fixed; inset:0; background:rgba(14,18,32,.6); display:none; align-items:center; justify-content:center; padding:16px; z-index:9999; }
    .overlay .sheet{ background:#fff; border:1px solid var(--line); border-radius:16px; padding:18px; max-width:420px; width:min(92vw,420px); box-shadow:0 20px 50px rgba(0,0,0,.25); }
    .overlay h3{ margin:0 0 8px 0; font-size:20px; font-weight:900 }
    .overlay p{ margin:0 0 10px 0; color:var(--muted) }
    .overlay .actions{ display:flex; gap:10px; justify-content:center; margin-top:12px }
    .overlay .actions .btn{ min-width:120px }

    /* Labels for pings/trails */
    .leaflet-tooltip.trailLabel{
      background: rgba(255,255,255,.9);
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 11px;
      color: var(--ink);
      box-shadow: 0 2px 6px rgba(0,0,0,.1);
    }
    /* Tiny seeker name labels */
    .leaflet-tooltip.seekLabel{
      background: rgba(255,255,255,.92);
      border: 1px solid #dde3ef;
      border-radius: 6px;
      padding: 1px 4px;
      font-size: 10px;
      color:#1c2437;
      box-shadow: 0 1px 4px rgba(0,0,0,.08);
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div>
        <div class="brand">Seekr.run</div>
        <div class="tag" id="gameTag">Loading game...</div>
      </div>
      <a href="demo.html" class="btn secondary">Back</a>
    </header>

    <section class="card">
      <div id="map" aria-label="Live game map"></div>
      <div class="hud">
        <span id="timePill" class="pill">Loading time…</span>
        <button id="btnActions" class="btn secondary" type="button">Actions</button>
        <button id="btnPing" class="btn" type="button">Send ping</button>
      </div>
      <div id="hint" class="notice"></div>
    </section>
  </div>

  <!-- End-of-game overlay -->
  <div id="end" class="overlay" role="dialog" aria-modal="true" aria-labelledby="endTitle" aria-hidden="true">
    <div class="sheet">
      <h3 id="endTitle">Round ended</h3>
      <p id="endMsg">Thanks for playing.</p>
      <div class="actions">
        <a href="demo.html" class="btn secondary">Back</a>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script type="module">
    // Firebase
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot,
      addDoc, collection, query, where, orderBy, limit, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    // Config
    const firebaseConfig = {
      apiKey: "AIzaSyAHJuv3vZH1dMzLkihl6hNQdlHOQNg728M",
      authDomain: "seekr-426ff.firebaseapp.com",
      projectId: "seekr-426ff",
      storageBucket: "seekr-426ff.firebasestorage.app",
      messagingSenderId: "703306109182",
      appId: "1:703306109182:web:afb04af22e974170e555af"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // UI refs
    const gameTag   = document.getElementById('gameTag');
    const timePill  = document.getElementById('timePill');
    const hint      = document.getElementById('hint');
    const toastEl   = document.getElementById('toast');
    const btnPing   = document.getElementById('btnPing');
    const btnActions= document.getElementById('btnActions');

    const endOverlay= document.getElementById('end');
    const endTitle  = document.getElementById('endTitle');
    const endMsg    = document.getElementById('endMsg');

    // Map + game state
    let map, myMarker, extractMarker;
    let role = null;
    let uncertaintyM = 50;
    let tagMeters = 2;
    let tickId = null;
    let revealToastShown = false;
    let geoWatchId = null;

    let areaCircle = null;
    let areaCenterLL = null;
    let areaRadiusM = 0;
    let zoneFitDone = false;

    // Presence / trail
    let lastCoords = null;
    let presenceTimer = null;
    let seekersNow = [];   // fugitives read this for tagging
    let secretLL = null;
    let gameEnded = false;

    // Fugitive pings
    let autoPingId = null;
    let autoPingEveryMs = 0;
    let didInitialAutoPing = false;

    // Seeker trail (fugitive)
    const trailColor = '#ff9500'; // orange
    let trailLayer = null;
    let trailLine = null;
    let trailListenerStarted = false;
    let currentFugitiveUid = null;

    // Seeker-to-seeker layer (visualization)
    let seekersLayer = null;
    const seekersMarkers = new Map(); // uid -> L.circleMarker
    let seekersRenderTimer = null;
    const SEEKERS_RENDER_MS = 60000; // show at 1-min cadence
    const seekersLive = new Map();   // uid -> {lat,lng,updatedAt}
    const memberNames = new Map();   // uid -> display name

    // Code
    const code = new URL(location.href).searchParams.get("code")?.toUpperCase() || "";

    // Map init
    function initMap(){
      map = L.map('map', { zoomControl:true, attributionControl:false });
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
      map.setView([51.505, -0.09], 15);
    }
    initMap();
    startGeoWatch();

    function updateMyMarker(lat, lng, recenter = false){
      const ll = [lat, lng];
      if (!myMarker) {
        myMarker = L.circleMarker(ll, {
          radius: 8, weight: 3, color: '#1e4cff', fillColor: '#1e4cff', fillOpacity: .35
        }).addTo(map);
      } else {
        myMarker.setLatLng(ll);
      }
      if (recenter && map) map.setView(ll, Math.max(map.getZoom(), 16));
    }

    function toast(t){
      toastEl.textContent = t;
      toastEl.style.display = 'block';
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(() => toastEl.style.display = 'none', 2200);
    }

    function showEndOverlay(winner, reason){
      endTitle.textContent = winner === "fugitive" ? "Fugitive Wins!" :
                             winner === "seeker"   ? "Seekers Win!"  : "Round Ended";
      endMsg.textContent = winner === "fugitive"
        ? (reason === "extract" ? "The fugitive reached extraction." : "The fugitives escaped.")
        : (winner === "seeker" ? "A seeker tagged the fugitive." : "Game over.");
      endOverlay.style.display = 'flex';
      endOverlay.setAttribute('aria-hidden', 'false');
    }

    async function endGame(winner, reason = "manual"){
      if (gameEnded) return;
      gameEnded = true;
      try{
        await setDoc(doc(db, "games", code), {
          status: "ended",
          winner,
          endReason: reason,
          endedAt: serverTimestamp()
        }, { merge:true });
      }catch(e){
        console.error("endGame failed", e);
        gameEnded = false;
      }
    }

    // Location
    function startGeoWatch(){
      if (geoWatchId) return;

      const isLocalhost = ['localhost', '127.0.0.1', '::1'].includes(location.hostname);
      if (!window.isSecureContext && !isLocalhost) {
        toast('Location needs HTTPS or localhost.');
        return;
      }
      if (!('geolocation' in navigator)){
        toast('Geolocation not available in this browser.');
        return;
      }

      navigator.geolocation.getCurrentPosition(
        pos => {
          lastCoords = pos.coords;
          updateMyMarker(pos.coords.latitude, pos.coords.longitude, true);
        },
        err => {
          console.warn('getCurrentPosition error', err);
          toast('Please allow location to see your dot.');
        },
        { enableHighAccuracy:true, maximumAge:5000, timeout:15000 }
      );

      geoWatchId = navigator.geolocation.watchPosition(
        pos => {
          lastCoords = pos.coords;
          updateMyMarker(pos.coords.latitude, pos.coords.longitude, false);

          // Win checks
          maybeCheckExtractionWin(pos.coords);
          maybeCheckTaggedBySeeker(pos.coords);
        },
        err => {
          console.warn('watchPosition error', err);
          if (!startGeoWatch._errShown){
            toast('Lost location updates. Move outside or check permissions.');
            startGeoWatch._errShown = true;
            setTimeout(()=> startGeoWatch._errShown = false, 8000);
          }
        },
        { enableHighAccuracy:true, maximumAge:5000, timeout:15000 }
      );
    }

    function maybeCheckExtractionWin(coords){
      if (role !== "fugitive" || !secretLL || gameEnded) return;
      const d = map.distance([coords.latitude, coords.longitude], secretLL);
      if (d <= 10){
        toast("You reached extraction");
        endGame("fugitive", "extract");
      }
    }

    function maybeCheckTaggedBySeeker(coords){
      if (role !== "fugitive" || !seekersNow.length || gameEnded) return;
      const me = L.latLng(coords.latitude, coords.longitude);
      for (const s of seekersNow){
        if (typeof s.lat !== "number" || typeof s.lng !== "number") continue;
        const d = map.distance(me, [s.lat, s.lng]);
        if (d <= tagMeters){
          toast("A seeker tagged you");
          endGame("seeker", "tag");
          break;
        }
      }
    }

    function watchMyPings(uid){
      const qMy = query(
        collection(db, "games", code, "pings"),
        where("uid", "==", uid),
        orderBy("createdAt", "desc"),
        limit(1)
      );
      onSnapshot(qMy, snap => {
        snap.forEach(d => {
          const p = d.data();
          const ll = [p.lat, p.lng];
          if (!myMarker) {
            myMarker = L.circleMarker(ll, { radius:8, weight:3, color:'#1e4cff', fillColor:'#1e4cff', fillOpacity:.35 }).addTo(map);
          } else {
            myMarker.setLatLng(ll);
          }
          if (map) map.setView(ll, Math.max(map.getZoom(), 15));
        });
      });
    }

    async function saveCurrentPing(reason = 'auto'){
      if (!lastCoords) return;
      try{
        const uid = auth.currentUser?.uid || null;
        await addDoc(collection(db, "games", code, "pings"), {
          lat: lastCoords.latitude,
          lng: lastCoords.longitude,
          role, uid, reason,
          createdAt: serverTimestamp()
        });
      }catch(e){
        console.warn("auto ping failed", e);
      }
    }

    // Seeker trail — robust & filtered to the active fugitive
    function startSeekerTrail(){
      if (trailLayer) return;

      trailLayer = L.layerGroup().addTo(map);
      trailLine = L.polyline([], { color:trailColor, weight:2, dashArray:'4,6', opacity:0.95 }).addTo(trailLayer);

      const qTrail = query(
        collection(db, "games", code, "pings"),
        where("role", "==", "fugitive"),
        orderBy("createdAt", "asc")
      );

      onSnapshot(qTrail, snap => {
        snap.docChanges().forEach(ch => {
          if (ch.type !== "added") return;
          const p = ch.doc.data();

          // filter by currently active fugitive (if set)
          if (currentFugitiveUid && p.uid !== currentFugitiveUid) return;

          if (typeof p.lat !== "number" || typeof p.lng !== "number") return;
          addTrailPoint(p.lat, p.lng, p.createdAt);
        });
      }, err => {
        console.error("trail listener error", err);
      });
    }

    function addTrailPoint(lat, lng, createdAt){
      const ll = [lat, lng];
      trailLine.addLatLng(ll);

      const mk = L.circleMarker(ll, {
        radius: 5, weight: 2, color: trailColor, fillColor: trailColor, fillOpacity: 0.9
      }).addTo(trailLayer);

      if (uncertaintyM > 0) {
        L.circle(ll, { radius: uncertaintyM, color: trailColor, weight:1, opacity:0.4, fillOpacity:0.08 }).addTo(trailLayer);
      }

      let t = null;
      if (createdAt && typeof createdAt.toDate === "function") t = createdAt.toDate();
      else if (createdAt && typeof createdAt.seconds === "number") t = new Date(createdAt.seconds * 1000);
      if (t) {
        const hh = String(t.getHours()).padStart(2, "0");
        const mm = String(t.getMinutes()).padStart(2, "0");
        mk.bindTooltip(`${hh}:${mm}`, {
          permanent:true, direction:"top", offset:[0,-8], opacity:0.95, className:"trailLabel"
        });
      }
    }

    function startSecretListener(){
      const secretRef = doc(db, "games", code, "private", "secret");
      onSnapshot(secretRef, snap => {
        if (!snap.exists() || extractMarker) return;
        const { lat, lng } = snap.data() || {};
        if (typeof lat !== "number" || typeof lng !== "number") return;

        extractMarker = L.circleMarker([lat, lng], {
          radius: 8, weight: 3, color: '#ffffff', fillColor: '#ff3b30', fillOpacity: 0.95
        }).addTo(map);

        secretLL = L.latLng(lat, lng);
        map.setView([lat, lng], Math.max(map.getZoom(), 16));
        toast("Extraction revealed, get within 10 meters to win.");
      }, err => {
        console.error("Secret listener error", err);
      });
    }

    // Seekers publish their own presence (5s cadence for tag accuracy)
    function startPresencePublisher(){
      if (presenceTimer || role !== "seeker") return;
      const myId = auth.currentUser?.uid;
      if (!myId) return;
      const presRef = doc(db, "games", code, "presence", myId);

      const publish = async () => {
        if (!lastCoords) return;
        try{
          await setDoc(presRef, {
            role: "seeker",
            lat: lastCoords.latitude,
            lng: lastCoords.longitude,
            updatedAt: serverTimestamp()
          }, { merge:true });
        }catch(e){
          console.warn("presence write failed", e);
        }
      };
      publish();
      presenceTimer = setInterval(publish, 5000);
    }

    // Fugitives read seekers for tag detection
    function startReadingSeekersForFugitive(){
      const qSeekers = query(
        collection(db, "games", code, "presence"),
        where("role", "==", "seeker")
      );
      onSnapshot(qSeekers, snap => {
        seekersNow = snap.docs
          .map(d => d.data())
          .filter(d => typeof d.lat === "number" && typeof d.lng === "number");
      }, err => console.error("presence read error", err));
    }

    // Seekers see other seekers as black dots with tiny labels (1-min render cadence)
    function startSeekersVisualizer(){
      if (seekersLayer) return;
      seekersLayer = L.layerGroup().addTo(map);

      const myId = auth.currentUser?.uid;

      // Load/display member names (for labels)
      onSnapshot(collection(db, "games", code, "members"), snap => {
        snap.forEach(docu => {
          const d = docu.data() || {};
          const nm = d.name || d.displayName || d.nickname || (d.role === 'fugitive' ? 'Fugitive' : 'Seeker');
          memberNames.set(docu.id, String(nm));
        });
      });

      // Live presence for seekers
      const qSeekers = query(
        collection(db, "games", code, "presence"),
        where("role", "==", "seeker")
      );
      onSnapshot(qSeekers, snap => {
        snap.forEach(docu => {
          const d = docu.data() || {};
          if (typeof d.lat === "number" && typeof d.lng === "number") {
            seekersLive.set(docu.id, { lat:d.lat, lng:d.lng, updatedAt:d.updatedAt });
          }
        });
        if (!seekersRenderTimer) renderSeekers(true);
      });

      seekersRenderTimer = setInterval(renderSeekers, SEEKERS_RENDER_MS);

      function renderSeekers(isImmediate=false){
        if (!seekersLayer) return;
        seekersLayer.clearLayers();
        seekersMarkers.clear();

        seekersLive.forEach((val, uid) => {
          if (uid === myId) return; // don't duplicate my own blue dot
          const ll = [val.lat, val.lng];
          const mk = L.circleMarker(ll, {
            radius: 5,
            weight: 2,
            color: '#000000',
            fillColor: '#000000',
            fillOpacity: 0.9
          }).addTo(seekersLayer);

          const name = memberNames.get(uid) || 'Seeker';
          mk.bindTooltip(name, {
            permanent:true, direction:"top", offset:[0,-8], opacity:0.95, className:"seekLabel"
          });

          seekersMarkers.set(uid, mk);
        });
      }
    }

    // ---------------------
    // PRIME + SUBSCRIBE flow
    // ---------------------

    function toMs(v){
      if (!v) return 0;
      if (typeof v === "number") return v < 1e12 ? v * 1000 : v;
      if (typeof v === "string") { const t = Date.parse(v); return Number.isNaN(t) ? 0 : t; }
      if (typeof v === "object" && typeof v.toMillis === "function") return v.toMillis();
      if (typeof v === "object" && typeof v.toDate === "function") return v.toDate().getTime();
      if (typeof v === "object" && typeof v.seconds === "number") {
        return v.seconds * 1000 + Math.floor((v.nanoseconds || 0) / 1e6);
      }
      return 0;
    }

    function applyGameDoc(g){
      // Redirect to lobby if not live yet
      if (g.status === "lobby") {
        toast("Waiting in lobby…");
        location.replace(`lobby.html?code=${encodeURIComponent(code)}`);
        return;
      }

      // Track current fugitive uid and reset trail if it changes (for seekers)
      const nextFug = g.fugitiveUid || null;
      const fugChanged = nextFug !== currentFugitiveUid;
      currentFugitiveUid = nextFug;

      if (role === "seeker" && !trailListenerStarted) {
        startSeekerTrail();
        trailListenerStarted = true;
      }
      if (role === "seeker" && fugChanged && trailLayer && trailLine) {
        trailLayer.clearLayers();
        trailLine = L.polyline([], { color:trailColor, weight:2, dashArray:'4,6', opacity:0.95 }).addTo(trailLayer);
      }

      // Ended?
      if (g.status === "ended"){
        gameEnded = true;
        if (tickId) { clearInterval(tickId); tickId = null; }
        if (autoPingId) { clearInterval(autoPingId); autoPingId = null; }
        if (presenceTimer) { clearInterval(presenceTimer); presenceTimer = null; }
        if (seekersRenderTimer) { clearInterval(seekersRenderTimer); seekersRenderTimer = null; }
        if (geoWatchId) { navigator.geolocation.clearWatch(geoWatchId); geoWatchId = null; }
        btnPing.disabled = true;
        timePill.textContent = "Time, round ended";
        showEndOverlay(g.winner || "unknown", g.endReason || "");
        return;
      }

      // Draw/refresh zone
      const z = g.zone || null;
      const hasCenter = z && z.center && typeof z.center.lat === "number" && typeof z.center.lng === "number";
      const radiusKm =
        z && typeof z.radius_km === "number" ? z.radius_km :
        z && typeof z.radius_m  === "number" ? z.radius_m / 1000 :
        null;

      if (hasCenter && typeof radiusKm === "number" && Number.isFinite(radiusKm)) {
        areaCenterLL = L.latLng(z.center.lat, z.center.lng);
        areaRadiusM = Math.max(50, Math.round(radiusKm * 1000));
        if (!areaCircle) {
          areaCircle = L.circle(areaCenterLL, {
            radius: areaRadiusM,
            color: "#1e4cff",
            weight: 2,
            fillColor: "#1e4cff",
            fillOpacity: 0.08,
            dashArray: "4,6"
          }).addTo(map);
          if (!zoneFitDone && !myMarker) {
            map.fitBounds(areaCircle.getBounds());
            zoneFitDone = true;
          }
        } else {
          areaCircle.setLatLng(areaCenterLL);
          areaCircle.setRadius(areaRadiusM);
        }
      }

      // Rules
      const cfg = g.lobbyConfig || {};
      uncertaintyM = Number(cfg.uncertaintyM ?? g.rules?.uncertainty_m ?? 50);
      tagMeters    = Number(g.rules?.tag_meters ?? 2);

      // Fugitive auto pings vs seeker trail attachment
      const pingMinutes = Number(g.rules?.ping_minutes || 0);
      const desiredMs = pingMinutes > 0 ? pingMinutes * 60 * 1000 : 0;

      if (role === "fugitive") {
        if (autoPingId && autoPingEveryMs !== desiredMs) {
          clearInterval(autoPingId); autoPingId = null;
        }
        if (!autoPingId && desiredMs > 0) {
          autoPingEveryMs = desiredMs;
          didInitialAutoPing = false;
          if (lastCoords) saveCurrentPing("interval-start").catch(()=>{});
          autoPingId = setInterval(() => saveCurrentPing("interval"), desiredMs);
        }
      } else {
        if (autoPingId) { clearInterval(autoPingId); autoPingId = null; }
      }

      // Times
      const endsAtMs = toMs(g.endsAt) || toMs(g.revealSchedule?.endAt);
      const startMs  = toMs(g.startsAt);
      const rulesMinutes = Number(g.rules?.game_minutes || 0);
      const durMs = g.durationMs || (rulesMinutes > 0 ? rulesMinutes * 60 * 1000 : 0);

      let endMs = endsAtMs;
      if (!endMs && startMs && durMs) endMs = startMs + durMs;

      let revealAtMs = toMs(g.revealAt) || toMs(g.revealSchedule?.revealAt);

      // If fugitive has a GPS fix and round is live, guarantee a first ping quickly
      if (role === "fugitive" && g.status === "live" && lastCoords && !didInitialAutoPing) {
        saveCurrentPing("round-start").catch(()=>{});
        didInitialAutoPing = true;
      }

      // Start secret listener for fugitives after reveal moment
      if (role === "fugitive" && revealAtMs && Date.now() >= revealAtMs && !extractMarker) {
        startSecretListener();
      }

      const nowMs = Date.now();

      // Prestart countdown
      if (startMs && startMs > nowMs) {
        const until = startMs - nowMs;
        const m = Math.floor(until / 60000);
        const s = String(Math.floor((until % 60000) / 1000)).padStart(2, "0");
        timePill.textContent = `Starts in, ${m}:${s}`;
        if (tickId) { clearInterval(tickId); tickId = null; }
        return;
      }

      if (!endMs) {
        timePill.textContent = "Time, waiting";
        if (tickId) { clearInterval(tickId); tickId = null; }
        return;
      }

      if (endMs <= nowMs) {
        timePill.textContent = "Time, round ended";
        if (tickId) { clearInterval(tickId); tickId = null; }
        return;
      }

      if (tickId) clearInterval(tickId);
      const tick = () => {
        const now = Date.now();
        const left = Math.max(0, endMs - now);
        const m = Math.floor(left / 60000);
        const s = String(Math.floor((left % 60000) / 1000)).padStart(2, "0");
        timePill.textContent = `Time, ${m}:${s}`;

        if (role === "fugitive" && revealAtMs && now >= revealAtMs && !extractMarker) {
          startSecretListener();
        }
        if (role === "seeker" && revealAtMs && now >= revealAtMs && !revealToastShown) {
          toast("Extraction location has been disclosed to fugitives.");
          revealToastShown = true;
        }

        if (left === 0) { clearInterval(tickId); tickId = null; }
      };
      tick();
      tickId = setInterval(tick, 1000);
    }

    // Auth + wire up
    onAuthStateChanged(auth, async user => {
      if (!user) return;
      if (!code) { toast("Missing code in URL"); return; }

      // Read my membership to infer role (created via lobby)
      const memberRef = doc(db, "games", code, "members", user.uid);
      let storedRole = null;
      try {
        const m = await getDoc(memberRef);
        storedRole = m.exists() ? (m.data().role || null) : null;
      } catch (e) {
        console.warn("Cannot read membership; open the lobby first to join.", e);
      }
      role = storedRole || null;
      if (!role) {
        // No role? Go to lobby.
        location.replace(`lobby.html?code=${encodeURIComponent(code)}`);
        return;
      }

      gameTag.textContent = "Game " + code + " • You are " + role;
      const uid = auth.currentUser?.uid;
      if (uid) watchMyPings(uid);

      if (role === "seeker") {
        startSeekerTrail();       // start immediately (no wait for snapshot)
        trailListenerStarted = true;
        startPresencePublisher();
        startSeekersVisualizer();
      }
      if (role === "fugitive") {
        startReadingSeekersForFugitive();
      }

      // PRIME once so UI doesn't sit at 00:01
      const gameRef = doc(db, "games", code);
      try {
        const snap = await getDoc(gameRef);
        if (snap.exists()) applyGameDoc(snap.data());
      } catch (_) {
        /* non-fatal; live sub will still attach */
      }

      // Live updates
      onSnapshot(
        gameRef,
        s => { if (s.exists()) applyGameDoc(s.data()); },
        err => {
          console.error("onSnapshot error for games/%s", code, err);
          hint.textContent = "Cannot read game, check Firestore rules.";
          if (tickId) { clearInterval(tickId); tickId = null; }
        }
      );

      // Enable manual ping
      btnPing.disabled = false;
    });

    signInAnonymously(auth).catch(console.error);

    // Actions button
    btnActions.addEventListener('click', () => {
      toast("Actions coming soon, Decoy Ping, Delay Reveal.");
    });

    // Manual ping button
    btnPing.addEventListener('click', () => {
      if (!('geolocation' in navigator)) { toast("Location not available"); return; }
      const uid = auth.currentUser?.uid || null;
      navigator.geolocation.getCurrentPosition(async pos => {
        const { latitude: lat, longitude: lng } = pos.coords;
        await addDoc(collection(db, "games", code, "pings"), {
          lat, lng, role, uid, createdAt: serverTimestamp()
        });
        if (map) map.setView([lat, lng], Math.max(map.getZoom(), 16));
        toast("Ping sent");
      }, () => toast("Could not get location"), { enableHighAccuracy: true, timeout: 12000 });
    });

    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (tickId) clearInterval(tickId);
      if (autoPingId) clearInterval(autoPingId);
      if (presenceTimer) clearInterval(presenceTimer);
      if (seekersRenderTimer) clearInterval(seekersRenderTimer);
      if (geoWatchId) { navigator.geolocation.clearWatch(geoWatchId); geoWatchId = null; }
    });
  </script>
</body>
</html>
